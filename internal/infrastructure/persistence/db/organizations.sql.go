// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organizations.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (id, project_id, name, created_at)
VALUES ($1, $2, $3, $4)
RETURNING id, project_id, name, created_at
`

type CreateOrganizationParams struct {
	ID        uuid.UUID `json:"id"`
	ProjectID uuid.UUID `json:"project_id"`
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRow(ctx, createOrganization,
		arg.ID,
		arg.ProjectID,
		arg.Name,
		arg.CreatedAt,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT id, project_id, name, created_at
FROM organizations
WHERE id = $1 AND project_id = $2
`

type GetOrganizationByIDParams struct {
	ID        uuid.UUID `json:"id"`
	ProjectID uuid.UUID `json:"project_id"`
}

func (q *Queries) GetOrganizationByID(ctx context.Context, arg GetOrganizationByIDParams) (Organization, error) {
	row := q.db.QueryRow(ctx, getOrganizationByID, arg.ID, arg.ProjectID)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const listOrganizationsByProjectID = `-- name: ListOrganizationsByProjectID :many
SELECT id, project_id, name, created_at
FROM organizations
WHERE project_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrganizationsByProjectIDParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListOrganizationsByProjectID(ctx context.Context, arg ListOrganizationsByProjectIDParams) ([]Organization, error) {
	rows, err := q.db.Query(ctx, listOrganizationsByProjectID, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationsForUser = `-- name: ListOrganizationsForUser :many
SELECT o.id, o.project_id, o.name, o.created_at
FROM organizations o
INNER JOIN organization_members m ON m.organization_id = o.id
WHERE o.project_id = $1 AND m.user_id = $2
ORDER BY o.created_at DESC
`

type ListOrganizationsForUserParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) ListOrganizationsForUser(ctx context.Context, arg ListOrganizationsForUserParams) ([]Organization, error) {
	rows, err := q.db.Query(ctx, listOrganizationsForUser, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrganizationName = `-- name: UpdateOrganizationName :exec
UPDATE organizations SET name = $1 WHERE id = $2 AND project_id = $3
`

type UpdateOrganizationNameParams struct {
	Name      string    `json:"name"`
	ID        uuid.UUID `json:"id"`
	ProjectID uuid.UUID `json:"project_id"`
}

func (q *Queries) UpdateOrganizationName(ctx context.Context, arg UpdateOrganizationNameParams) error {
	_, err := q.db.Exec(ctx, updateOrganizationName, arg.Name, arg.ID, arg.ProjectID)
	return err
}
